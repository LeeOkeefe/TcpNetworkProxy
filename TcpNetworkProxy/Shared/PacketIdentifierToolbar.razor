@if (SelectedNetworkEntry is not null)
{
    <MudPaper Elevation="0">
        @if (SelectedBytes is not null)
        {
            <MudGrid>
                <MudItem md="2">
                    <MudButton FullWidth StartIcon="@Icons.Material.Filled.KeyboardDoubleArrowLeft" IconColor="Color.Secondary" Variant="Variant.Text" Color="Color.Primary" Class="py-0">
                        Shift Left
                    </MudButton>
                </MudItem>
                <MudItem md="8">
                    <MudStack Row Justify="Justify.SpaceEvenly">
                        <MudText Typo="Typo.button" Align="Align.Center">Little Endian: @GetEndian().little</MudText>
                        <MudText Typo="Typo.button" Align="Align.Center">Shifted: 0</MudText>
                        <MudText Typo="Typo.button" Align="Align.Center">Big Endian: @GetEndian().big</MudText>
                    </MudStack>
                </MudItem>
                <MudItem md="2">
                    <MudButton FullWidth EndIcon="@Icons.Material.Filled.KeyboardDoubleArrowRight" IconColor="Color.Secondary" Variant="Variant.Text" Color="Color.Primary" Class="py-0">
                        Shift Right
                    </MudButton>
                </MudItem>
            </MudGrid>
        }
        else
        {
            <MudText>No hexadecimal bytes selected.</MudText>
        }
    </MudPaper>
}

@code {

    [Parameter]
    public NetworkEntryViewModel SelectedNetworkEntry { get; set; }
    
    [Parameter]
    public DataTypeViewModel SelectedDataType { get; set; }
    
    [Parameter]
    public IReadOnlyCollection<HexadecimalViewModel> SelectedBytes { get; set; }

    private NetworkEntryViewModel _previousNetworkEntry;
    private IReadOnlyCollection<HexadecimalViewModel> _previousBytes;

    protected override void OnParametersSet()
    {
        if (SelectedNetworkEntry != _previousNetworkEntry || !Equals(SelectedBytes, _previousBytes))
        {
            StateHasChanged();
        }
        base.OnParametersSet();
    }

    private (string little, string big) GetEndian()
    {
        var bytesToConvert = GetOrderedBytes();

        var bytes = ConvertBytes(bytesToConvert, SelectedDataType.Type);
        var bytesReversed = ConvertBytes(bytesToConvert.Reverse().ToArray(), SelectedDataType.Type);
        
        return BitConverter.IsLittleEndian ? (bytes, bytesReversed) : (bytesReversed, bytes);
    }

    private byte[] GetOrderedBytes()
    {
        return SelectedBytes
            .OrderBy(b => b.Index)
            .Select(b => b.Byte)
            .ToArray();
    }

    private string ConvertBytes(byte[] bytes, Type type)
    {
        return Type.GetTypeCode(type) switch
        {
            TypeCode.Int32 when bytes.Length >= sizeof(int) => BitConverter.ToInt32(bytes).ToString(),
            TypeCode.Int64 when bytes.Length >= sizeof(long) => BitConverter.ToInt64(bytes).ToString(),
            TypeCode.Int16 when bytes.Length >= sizeof(short) => BitConverter.ToInt16(bytes).ToString(),
            TypeCode.Byte when bytes.Length >= 1 => bytes[0].ToString(),
            _ => string.Empty
        };
    }
}