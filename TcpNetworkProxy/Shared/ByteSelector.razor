@using System.ComponentModel

@if (_hexBytes.Count == 0)
{
    <MudText>No network packet selected.</MudText>
}
else
{
    <div class="hex-string">
        @foreach (var hexByte in _hexBytes)
        {
            <span class="hex-byte @(hexByte.IsSelected ? "highlighted" : string.Empty)"
                  @onclick="() => SelectBytes(hexByte)">
                @hexByte.Value
            </span>
        }
    </div>
}

@code {

    [Parameter]
    public EventCallback<IReadOnlyCollection<HexByteViewModel>> OnHexBytesSelected { get; set; }

    [Parameter]
    public DataTypeViewModel DataType { get; set; }

    [Parameter]
    public string HexString { get; set; }

    private List<HexByteViewModel> _hexBytes = new();
    private int _selectedByteIndex;

    private string _previousDataTypeName;
    private string _previousHexString;
    
    protected override void OnParametersSet()
    {
        if (HexString is null || _previousHexString == HexString && _previousDataTypeName == DataType?.TypeName)
        {
            return;
        }
        
        _hexBytes = GetHexBytes(HexString);

        if (_selectedByteIndex > _hexBytes.Count)
        {
            ResetByteSelection(); 
        }

        SelectBytes(_hexBytes[_selectedByteIndex]);
        
        _previousDataTypeName = DataType?.TypeName;
        _previousHexString = HexString;
    }

    private List<HexByteViewModel> GetHexBytes(string hexString)
    {
        return hexString.Split(" ").Select((h, i) =>
            new HexByteViewModel { Index = i, Value = h, IsSelected = false }).ToList();
    }

    private void SelectBytes(HexByteViewModel hexByteViewModel)
    {
        ResetByteSelection();

        if (DataType == null)
        {
            return;
        }

        _selectedByteIndex = hexByteViewModel.Index;
        var hexIndexRange = hexByteViewModel.Index + DataType.SizeInBytes;
        if (hexIndexRange > _hexBytes.Count)
        {
            return;
        }

        for (var i = hexByteViewModel.Index; i < hexIndexRange; i++)
        {
            _hexBytes[i].IsSelected = true;
        }

        var selectedHexBytes = _hexBytes.Where(h => h.IsSelected).ToArray();
        if (OnHexBytesSelected.HasDelegate)
        {
            OnHexBytesSelected.InvokeAsync(selectedHexBytes);
        }
    }

    private void ResetByteSelection()
    {
        _selectedByteIndex = 0;

        foreach (var hex in _hexBytes.Where(hex => hex.IsSelected))
        {
            hex.IsSelected = false;
        }
    }

}